name: CI/CD Deployment - Self-Hosted VM (No Registry)

on:
  push:
    branches:
      - main
  workflow_dispatch: # Permet de lancer manuellement

env:
  CONSUMER_IMAGE: post-consumer:latest
  PUSHER_IMAGE: post-pusher-kafka:latest
  SA_SECRET_NAME: gcp-sa-secret
  KIND_CLUSTER_NAME: devops-kind-cluster # Nom du cluster Kind
  
jobs:
  build-and-deploy-on-vm:
    runs-on: self-hosted 
    
    steps:
      - name: üì• Checkout Code
        uses: actions/checkout@v4

      # --- 1. CONFIGURATION DU CLUSTER KIND (CORRECTION DNS ET KUBECONFIG) ---
      
      - name: ‚öôÔ∏è Setup Kind and Start Cluster
        run: |
          # 1. Cr√©ation du cluster uniquement s'il n'existe pas.
          if kind get clusters | grep -q "${{ env.KIND_CLUSTER_NAME }}"; then
            echo "Cluster Kind '${{ env.KIND_CLUSTER_NAME }}' existe d√©j√†. Utilisation de l'existant."
          else
            echo "Cluster Kind '${{ env.KIND_CLUSTER_NAME }}' n'existe pas. Cr√©ation en cours..."
            kind create cluster --name ${{ env.KIND_CLUSTER_NAME }} --config ./kind/config.yaml
          fi

          # 2. Obtention du Kubeconfig brut (avec nom d'h√¥te interne)
          KIND_KUBECONFIG=$(kind get kubeconfig --name ${{ env.KIND_CLUSTER_NAME }} --internal)
          
          # 3. CORRECTION DNS : Obtenir l'IP du conteneur Kind pour la connexion depuis la VM.
          #    Cela r√©sout l'erreur 'no such host'.
          CONTROL_PLANE_IP=$(docker inspect -f '{{.NetworkSettings.IPAddress}}' "${{ env.KIND_CLUSTER_NAME }}-control-plane")
          
          # 4. Remplacer le nom d'h√¥te interne par l'adresse IP et le port 6443.
          KIND_KUBECONFIG_FIXED=$(echo "$KIND_KUBECONFIG" | sed "s/server: https:\/\/.*/server: https:\/\/$CONTROL_PLANE_IP:6443/")
          
          # 5. Injecter le Kubeconfig corrig√© (avec l'IP) dans l'environnement (Correction EOF).
          echo 'KUBECONFIG_CONTEXT<<EOF' >> $GITHUB_ENV
          echo "$KIND_KUBECONFIG_FIXED" >> $GITHUB_ENV
          echo 'EOF' >> $GITHUB_ENV

      - name: Configure Kubectl (Installer l'ex√©cutable)
        uses: azure/setup-kubectl@v3
        with:
          version: 'latest'

      - name: üîó Set K8s Context for Azure Actions
        uses: azure/k8s-set-context@v3
        with:
          method: kubeconfig
          # Utilise la variable d'environnement KUBECONFIG_CONTEXT qui contient l'IP corrig√©e
          kubeconfig: ${{ env.KUBECONFIG_CONTEXT }}
          cluster-context: kind-${{ env.KIND_CLUSTER_NAME }}
          
      # --- 2. CONSTRUCTION DES IMAGES (sur la VM) ---
      
      - name: üî® Build and Load Consumer Image
        uses: docker/build-push-action@v5
        with:
          context: ./post_consumer
          file: ./post_consumer/Dockerfile
          push: false 
          load: true 
          tags: ${{ env.CONSUMER_IMAGE }}
          
      - name: üî® Build and Load Pusher Image
        uses: docker/build-push-action@v5
        with:
          context: ./post_pusher
          file: ./post_pusher/Dockerfile
          push: false
          load: true
          tags: ${{ env.PUSHER_IMAGE }}

      # --- 3. D√âPLOIEMENT KUBERNETES ---

      # CORRECTION SECRET : Utilisation de la m√©thode --from-file (fichier temporaire) 
      # pour √©viter les erreurs de formatage Shell avec les sauts de ligne du JSON.
      - name: üîë Create/Update Secret for Service Account (GCP)
        run: |
          echo "Cr√©ation du fichier temporaire pour le secret GCP..."
          # 1. √âcrit le contenu du secret multi-lignes dans un fichier temporaire
          echo "${{ secrets.SA_JSON }}" > sa-gcp.json
          
          # 2. Utilise kubectl pour cr√©er/appliquer le secret √† partir du fichier
          # Note: --from-file est la m√©thode la plus robuste.
          kubectl create secret generic ${{ env.SA_SECRET_NAME }} \
            --from-file=service-account.json=sa-gcp.json \
            --namespace=default \
            --dry-run=client -o yaml | kubectl apply -f -
            
          # 3. Supprime le fichier temporaire
          rm sa-gcp.json

      - name: üöÄ Deploy Kafka Infrastructure
        uses: azure/k8s-deploy@v4
        with:
          namespace: default
          manifests: |
            kafka/configmap.yaml
            kafka/service.yaml
            kafka/deployment.yaml

      - name: üöÄ Deploy Kafka UI
        uses: azure/k8s-deploy@v4
        with:
          namespace: default
          manifests: |
            ui/service.yaml
            ui/deployment.yaml

      - name: üöÄ Deploy Application Deployments
        uses: azure/k8s-deploy@v4
        with:
          namespace: default
          manifests: |
            post_consumer/deployment.yaml
            post_pusher/deployment.yaml
          images: |
            ${{ env.CONSUMER_IMAGE }}
            ${{ env.PUSHER_IMAGE }}
            
      - name: ‚úÖ Deployment Complete
        run: echo "Le d√©ploiement est termin√©. Les images sont locales sur la VM."