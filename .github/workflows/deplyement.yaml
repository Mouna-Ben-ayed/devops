name: CI/CD Deployment - Self-Hosted VM (No Registry)

on:
  push:
    branches:
      - main
  workflow_dispatch:

env:
  CONSUMER_IMAGE: post-consumer:latest
  PUSHER_IMAGE: post-pusher-kafka:latest
  SA_SECRET_NAME: gcp-sa-secret
  KIND_CLUSTER_NAME: devops-kind-cluster

jobs:
  build-and-deploy-on-vm:
    runs-on: self-hosted

    steps:
      - name: ðŸ“¥ Checkout Code
        uses: actions/checkout@v4

      # --- 1. CONFIGURATION DU CLUSTER KIND ---
      - name: âš™ï¸ Setup Kind and Start Cluster
        run: |
          # CrÃ©er le cluster uniquement s'il n'existe pas
          if kind get clusters | grep -q "${{ env.KIND_CLUSTER_NAME }}"; then
            echo "Cluster Kind '${{ env.KIND_CLUSTER_NAME }}' existe dÃ©jÃ ."
          else
            kind create cluster --name ${{ env.KIND_CLUSTER_NAME }} --config ./kind/config.yaml
          fi

          # Export KUBECONFIG pour la VM
          export KUBECONFIG=$(kind get kubeconfig-path --name ${{ env.KIND_CLUSTER_NAME }})
          echo "KUBECONFIG=$KUBECONFIG" >> $GITHUB_ENV

      - name: Configure Kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'latest'

      - name: ðŸ”— Set Kubernetes Context
        uses: azure/k8s-set-context@v3
        with:
          method: kubeconfig
          kubeconfig: ${{ env.KUBECONFIG }}
          cluster-context: kind-${{ env.KIND_CLUSTER_NAME }}

      # --- 2. BUILD DES IMAGES DOCKER ---
      - name: ðŸ”¨ Build and Load Consumer Image
        uses: docker/build-push-action@v5
        with:
          context: ./post_consumer
          file: ./post_consumer/Dockerfile
          push: false
          load: true
          tags: ${{ env.CONSUMER_IMAGE }}

      - name: ðŸ”¨ Build and Load Pusher Image
        uses: docker/build-push-action@v5
        with:
          context: ./post_pusher
          file: ./post_pusher/Dockerfile
          push: false
          load: true
          tags: ${{ env.PUSHER_IMAGE }}

      - name: Wait for Kubernetes API
        run: kubectl wait --for=condition=ready node --all --timeout=300s

      # --- 3. SECRET GCP ---
      - name: Create/Update GCP Service Account Secret
        run: |
          kubectl create secret generic ${{ env.SA_SECRET_NAME }} \
            --from-literal=service-account.json='${{ secrets.SA_JSON }}' \
            --dry-run=client -o yaml | kubectl apply -f -

      # --- 4. DEPLOY KUBERNETES MANIFESTS ---
      - name: ðŸš€ Deploy Kafka Infrastructure
        uses: azure/k8s-deploy@v4
        with:
          namespace: default
          manifests: |
            kafka/configmap.yaml
            kafka/service.yaml
            kafka/deployment.yaml

      - name: ðŸš€ Deploy Kafka UI
        uses: azure/k8s-deploy@v4
        with:
          namespace: default
          manifests: |
            ui/service.yaml
            ui/deployment.yaml

      - name: ðŸš€ Deploy Application Deployments
        uses: azure/k8s-deploy@v4
        with:
          namespace: default
          manifests: |
            post_consumer/deployment.yaml
            post_pusher/deployment.yaml
          images: |
            ${{ env.CONSUMER_IMAGE }}
            ${{ env.PUSHER_IMAGE }}

      - name: âœ… Deployment Complete
        run: echo "DÃ©ploiement terminÃ©. Les images sont locales sur la VM."
