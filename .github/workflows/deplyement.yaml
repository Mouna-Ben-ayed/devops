name: CI/CD Kubernetes Deployment (Secure GCP Access - YQ Method)

on:
  push:
    branches:
      - main
  workflow_dispatch:

env:
  REGISTRY: ghcr.io
  IMAGE_OWNER: ${{ github.repository_owner }}
  SA_SECRET_NAME: gcp-sa-secret
  
jobs:
  build-and-push:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Login to GitHub Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ env.IMAGE_OWNER }}
        password: ${{ secrets.GITHUB_TOKEN }} 

    - name: Build and Push post-consumer image
      uses: docker/build-push-action@v5
      with:
        context: ./post_consumer
        file: ./post_consumer/Dokerfile 
        push: true
        tags: ${{ env.REGISTRY }}/${{ env.IMAGE_OWNER }}/post-consumer:${{ github.sha }}

    - name: Build and Push post-pusher image
      uses: docker/build-push-action@v5
      with:
        context: ./post_pusher 
        file: ./post_pusher/Dockerfile
        push: true
        tags: ${{ env.REGISTRY }}/${{ env.IMAGE_OWNER }}/post-pusher:${{ github.sha }}

  deploy:
    runs-on: ubuntu-latest
    needs: build-and-push
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure Kubectl and Tools
      uses: azure/setup-kubectl@v3
      with:
        version: 'latest'
        
    - name: Install yq (YAML Processor)
      run: sudo snap install yq
    
    - name: Set Kubeconfig
      run: |
        mkdir -p ~/.kube
        echo "${{ secrets.KUBECONFIG }}" > ~/.kube/config
      shell: bash

    - name: Create/Update Secret for Service Account
      run: |
        kubectl create secret generic ${{ env.SA_SECRET_NAME }} \
          --from-literal=service-account.json='${{ secrets.SA_JSON }}' \
          --dry-run=client -o yaml | kubectl apply -f -
      shell: bash

    - name: Patch Manifestes with yq
      run: |
        SHA_TAG=${{ github.sha }}
        REGISTRY_PATH="${{ env.REGISTRY }}/${{ env.IMAGE_OWNER }}"
        CONSUMER_DEPLOYMENT="post_consumer/deployement.yaml"
        PUSHER_DEPLOYMENT="post_pusher/deployement.yaml"
        UI_DEPLOYMENT="ui/deployement.yaml"
        
        # Le chemin de montage à l'intérieur du conteneur
        MOUNT_PATH='/service-account.json' 
        
        # --- Fonction de Patch générique pour SA (Service Account) ---
        patch_sa() {
          DEPLOYMENT_FILE=$1
          CONTAINER_NAME=$2
          
          # 1. Mise à jour de l'image (via le nom du conteneur)
          yq e '.spec.template.spec.containers[] |= 
                select(.name == "'"$CONTAINER_NAME"'").image = "'"$REGISTRY_PATH/$CONTAINER_NAME:$SHA_TAG"'"' -i "$DEPLOYMENT_FILE"
                
          # 2. Injection du Volume Mount dans le conteneur
          yq e '.spec.template.spec.containers[] |= 
                select(.name == "'"$CONTAINER_NAME"'").volumeMounts = [
                  {name: "gcp-sa-volume", mountPath: "'"$MOUNT_PATH"'", subPath: "service-account.json"}
                ]' -i "$DEPLOYMENT_FILE"

          # 3. Injection de la définition du Volume dans le Pod Spec
          yq e '.spec.template.spec.volumes = [
                  {name: "gcp-sa-volume", secret: {secretName: "'"${{ env.SA_SECRET_NAME }}"'"}}
                ]' -i "$DEPLOYMENT_FILE"
        }
        
        # --- APPLICATION DES PATCHS ---
        
        # Post Consumer
        # Le nom du conteneur est 'post-consumer' (d'après votre manifeste)
        patch_sa "$CONSUMER_DEPLOYMENT" "post-consumer"
        
        # Post Pusher
        # Le nom du conteneur est 'post-pusher-kafka' (d'après votre manifeste)
        patch_sa "$PUSHER_DEPLOYMENT" "post-pusher-kafka"

        # --- Patch Kafka UI (Décommenter ConfigMap) ---
        # 1. Injection du Volume Mount dans le conteneur 'kafka-ui'
        yq e '.spec.template.spec.containers[] |= 
              select(.name == "kafka-ui").volumeMounts = [
                {name: "config-volume", mountPath: "/etc/kafkaui/dynamic_config.yaml", subPath: "dynamic_config.yaml"}
              ]' -i "$UI_DEPLOYMENT"
              
        # 2. Injection de la définition du Volume (ConfigMap)
        yq e '.spec.template.spec.volumes = [
                {name: "config-volume", configMap: {name: "kafka-ui-config"}}
              ]' -i "$UI_DEPLOYMENT"
        
        echo "Tous les manifestes ont été patchés localement avec yq."
      shell: bash

    - name: Deploy to Kubernetes
      run: |
        echo "--- Applying Kafka Infrastructure ---"
        kubectl apply -f kafka/config.yaml
        kubectl apply -f kafka/service.yaml
        kubectl apply -f kafka/deployement.yaml
        
        echo "--- Applying Kafka UI ---"
        kubectl apply -f ui/service.yaml
        kubectl apply -f ui/deployement.yaml 
        
        echo "--- Applying Application Deployments (Pusher/Consumer) ---"
        kubectl apply -f post_consumer/deployement.yaml
        kubectl apply -f post_pusher/deployement.yaml
        
        echo "Deployment complete."
      shell: bash