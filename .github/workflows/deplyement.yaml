name: CI/CD Kubernetes Deployment (Secure GCP Access - FINAL SSH TUNNEL)

on:
  push:
    branches:
      - main
  workflow_dispatch:

env:
  REGISTRY: ghcr.io
  # Laissez IMAGE_OWNER tel quel, la conversion en minuscules se fait dans les √©tapes
  IMAGE_OWNER: ${{ github.repository_owner }} 
  SA_SECRET_NAME: gcp-sa-secret
  # L'IP publique de votre VM GCP
  VM_IP: 34.79.223.105
  # L'utilisateur SSH
  VM_USER: mouna_gcp
  # Le port local sur lequel l'API Kind √©coute (d√©duit de netstat)
  API_PORT: 40675 
  
jobs:
  build-and-push:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    # --- 1. GESTION DU NOMMAGE DOCKER (Minuscules) ---
    - name: ‚öôÔ∏è Set Lowercase Owner Name
      id: lowercase_owner
      run: |
        # Convertit le nom du propri√©taire en minuscules pour le r√©f√©rentiel Docker
        echo "owner_lc=$(echo ${{ github.repository_owner }} | tr '[:upper:]' '[:lower:]')" >> $GITHUB_OUTPUT

    - name: Login to GitHub Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ env.IMAGE_OWNER }}
        password: ${{ secrets.GITHUB_TOKEN }} 

    - name: Build and Push post-consumer image
      uses: docker/build-push-action@v5
      with:
        context: ./post_consumer
        file: ./post_consumer/Dockerfile
        push: true
        tags: ${{ env.REGISTRY }}/${{ steps.lowercase_owner.outputs.owner_lc }}/post-consumer:${{ github.sha }}

    - name: Build and Push post-pusher image
      uses: docker/build-push-action@v5
      with:
        context: ./post_pusher 
        file: ./post_pusher/Dockerfile
        push: true
        tags: ${{ env.REGISTRY }}/${{ steps.lowercase_owner.outputs.owner_lc }}/post-pusher:${{ github.sha }}

  deploy:
    runs-on: ubuntu-latest
    needs: build-and-push
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    # --- 2. GESTION DU NOMMAGE DOCKER (Pour le Patching) ---
    - name: ‚öôÔ∏è Set Lowercase Owner Name for Deployment
      id: lowercase_owner_deploy
      run: |
        echo "owner_lc=$(echo ${{ github.repository_owner }} | tr '[:upper:]' '[:lower:]')" >> $GITHUB_OUTPUT

    - name: Configure Kubectl and Tools
      uses: azure/setup-kubectl@v3
      with:
        version: 'latest'
        
    - name: Install yq (YAML Processor)
      run: sudo snap install yq
    
    - name: Set Kubeconfig
      run: |
        mkdir -p ~/.kube
        # Le KUBECONFIG doit pointer sur 127.0.0.1:40675 (car Kind √©coute en local)
        echo "${{ secrets.KUBECONFIG }}" > ~/.kube/config
      shell: bash

    # --- 3. MISE EN PLACE DU TUNNEL SSH (R√©sout Connection Refused) ---
    - name: üîê Setup SSH Tunnel to VM API
      env:
        SSH_KEY: ${{ secrets.GCP_SSH_KEY }}
      run: |
        echo "Configuration du tunnel SSH vers $VM_IP:$API_PORT"
        
        # 1. Configurer la cl√© priv√©e SSH
        mkdir -p ~/.ssh
        echo "$SSH_KEY" > ~/.ssh/id_rsa
        chmod 600 ~/.ssh/id_rsa
        
        # 2. Ajouter l'IP du serveur aux h√¥tes connus
        ssh-keyscan -H ${{ env.VM_IP }} >> ~/.ssh/known_hosts
        
        # 3. √âtablir le tunnel SSH en arri√®re-plan (Port Forwarding)
        # Ceci mappe le port 40675 du runner vers 127.0.0.1:40675 sur la VM.
        ssh -i ~/.ssh/id_rsa -N -L ${{ env.API_PORT }}:127.0.0.1:${{ env.API_PORT }} ${{ env.VM_USER }}@${{ env.VM_IP }} &
        
        # Attendre un court instant pour que le tunnel soit actif
        sleep 5
      shell: bash

    # --- 4. EX√âCUTION DES COMMANDES KUBECTL (via le Tunnel) ---
    - name: Wait for Kubernetes API to be Ready (via Tunnel)
      run: |
        # Le KUBECONFIG utilise 127.0.0.1, qui est intercept√© par le tunnel SSH.
        kubectl wait --for=condition=ready node --all --timeout=300s
      shell: bash

    - name: Create/Update Secret for Service Account
      run: |
        kubectl create secret generic ${{ env.SA_SECRET_NAME }} \
          --from-literal=service-account.json='${{ secrets.SA_JSON }}' \
          --dry-run=client -o yaml | kubectl apply -f -
      shell: bash

    - name: Patch Manifestes with yq
      run: |
        SHA_TAG=${{ github.sha }}
        OWNER_LC="${{ steps.lowercase_owner_deploy.outputs.owner_lc }}" 
        REGISTRY_PATH="${{ env.REGISTRY }}/$OWNER_LC"
        SA_SECRET="${{ env.SA_SECRET_NAME }}"
        
        CONSUMER_DEPLOYMENT="post_consumer/deployement.yaml"
        PUSHER_DEPLOYMENT="post_pusher/deployement.yaml"
        UI_DEPLOYMENT="ui/deployement.yaml"
        MOUNT_PATH='/service-account.json' 
        
        patch_sa() {
          DEPLOYMENT_FILE=$1
          CONTAINER_NAME=$2
          
          # 1. Mise √† jour de l'image
          yq e '.spec.template.spec.containers[] |= 
                select(.name == "'"$CONTAINER_NAME"'").image = "'"$REGISTRY_PATH/$CONTAINER_NAME:$SHA_TAG"'"' -i "$DEPLOYMENT_FILE"
                
          # 2. Injection du Volume Mount
          yq e '.spec.template.spec.containers[] |= 
                select(.name == "'"$CONTAINER_NAME"'").volumeMounts = [
                  {name: "gcp-sa-volume", mountPath: "'"$MOUNT_PATH"'", subPath: "service-account.json"}
                ]' -i "$DEPLOYMENT_FILE"

          # 3. Injection de la d√©finition du Volume
          yq e '.spec.template.spec.volumes = [
                  {name: "gcp-sa-volume", secret: {secretName: "'"${{ env.SA_SECRET_NAME }}"'"}}
                ]' -i "$DEPLOYMENT_FILE"
        }
        
        # --- APPLICATION DES PATCHS ---
        patch_sa "$CONSUMER_DEPLOYMENT" "post-consumer"
        patch_sa "$PUSHER_DEPLOYMENT" "post-pusher-kafka"

        # --- Patch Kafka UI (ConfigMap) ---
        yq e '.spec.template.spec.containers[] |= 
              select(.name == "kafka-ui").volumeMounts = [
                {name: "config-volume", mountPath: "/etc/kafkaui/dynamic_config.yaml", subPath: "dynamic_config.yaml"}
              ]' -i "$UI_DEPLOYMENT"
              
        yq e '.spec.template.spec.volumes = [
                {name: "config-volume", configMap: {name: "kafka-ui-config"}}
              ]' -i "$UI_DEPLOYMENT"
        
        echo "Tous les manifestes ont √©t√© patch√©s localement avec yq."
      shell: bash

    - name: Deploy to Kubernetes
      run: |
        echo "--- Applying Kafka Infrastructure ---"
        kubectl apply -f kafka/config.yaml
        kubectl apply -f kafka/service.yaml
        kubectl apply -f kafka/deployement.yaml
        
        echo "--- Applying Kafka UI ---"
        kubectl apply -f ui/service.yaml
        kubectl apply -f ui/deployement.yaml 
        
        echo "--- Applying Application Deployments (Pusher/Consumer) ---"
        kubectl apply -f post_consumer/deployement.yaml
        kubectl apply -f post_pusher/deployement.yaml
        
        echo "Deployment complete."
      shell: bash